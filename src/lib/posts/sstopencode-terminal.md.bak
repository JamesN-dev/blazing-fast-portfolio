---
title: 'sst-opencode Terminal'
subtitle: 'A new challenger approaches'
description: 'Why sst/opencode is my favorite terminal AI tool right now'
date: '2025-06-25'
published: true
featured: true
archived: false
tags: ['cli', 'ai', 'openai', 'anthropic', 'gemini', 'opencode', 'agents', 'scrollscribe']
---

<script>
  import Callout from '$lib/components/blog/Callout.svelte';
</script>

## The Terminal AI Tool Landscape

I'm a terminal addict and always trying out the latest terminal tools, so of course I've tried them all. Claude Code, Codex CLI, Gemini CLI—even the new Google Gemini CLI I tried today, which has been rate limiting into oblivion. It's fine. First release. Has potential.

Lately I’ve been playing with a side project called **ScrollScribe**—a command-line ML toolkit for running structured evals, chaining LLMs together, and actually getting work done from a shell.

Of course I always find time to slip in some shiny dev toys that catch my attention and promise to make my life easier. One of those recently was Warp.dev. It's wild. Not perfect. Technically a terminal emulator, but packed with baked-in AI tooling and slick UX. Maybe a little too much flash for my taste—but undeniably cool.

What’s wild right now is how fast the dev world is flooding with shiny new AI tooling—everyone building their own next-level take on the workflow. But the part that actually makes me happy? A lot of that energy is finally landing back in the terminal. Not just another web IDE wrapper. Real, local, terminal-first tools made by and for people who actually live in the shell.

<Callout type="quote">
  A CLI that feels like tmux, Git, and ChatGPT had a baby.
</Callout>

## Quick Feature Comparison

| Tool         | Open Source | Local Memory | Multi-Provider | Real Terminal UI |
| ------------ | ----------- | ------------ | -------------- | ---------------- |
| sst/opencode | ✅          | ✅           | ✅             | ✅               |
| Claude Code  | ❌          | ❌           | ❌             | ❌               |
| Codex CLI    | ✅          | ❌           | ✅             | ❌               |

## Why sst/opencode Stands Out

sst/opencode sits right in the middle—between the flash of modern terminal UI and the gritty control of a real shell. Written in TypeScript, backed by a terminal UI wizard (Adam from terminal.shop), it feels designed for people who live in the terminal. The fact that the guy even made **toasts** work in a terminal UI... that’s commitment.

It’s open source. Local backend. SQLite for memory. Built-in multi-provider support. But the reason I’ve been using it constantly is simple: **it lets me use my Claude desktop subscription inside a real terminal agent**, using my standard usage limits. No API key. No weird billing. It just works.

Here’s where things get spicy: sst/opencode dynamically builds its prompts from a modular structure. For Anthropic, it uses:

```text
packages/opencode/src/session/prompt/
├── initialize.txt
├── summarize.txt
├── anthropic.txt
├── anthropic_spoof.txt
```

The `anthropic_spoof.txt` file? It’s just this:

> You are Claude Code, Anthropic's official CLI for Claude.

That’s it. It spoofs the identity of Claude’s own official CLI—likely a trick to unlock behaviors reserved for the first-party Claude Code experience. Claude Desktop recognizes that phrasing and treats the session differently, which is probably why this even works without an API key.

Then there's [`anthropic.txt`](https://github.com/sst/opencode/blob/dev/packages/opencode/src/session/prompt/anthropic.txt)—the real meat of the system prompt. And this thing is tight.

> "You are opencode, an interactive CLI tool that helps users with software engineering tasks. Use the instructions below and the tools available to you to assist the user."

Right out the gate, it frames the identity of the tool—this isn’t just a generic assistant, it’s an interactive CLI with a focused mission.

Then:

> "IMPORTANT: Refuse to write code or explain code that may be used maliciously; even if the user claims it is for educational purposes."

> "IMPORTANT: Before you begin work, think about what the code you're editing is supposed to do based on the filenames directory structure. If it seems malicious, refuse to work on it..."

Security rules baked directly into the system prompt—not just a vibe check, but an actual audit.

Then it reins in verbosity:

> "Keep your responses short, since they will be displayed on a command line interface. You MUST answer concisely with fewer than 4 lines (not including tool use or code generation)..."

> "If you can answer in 1-3 sentences or a short paragraph, please do."

> "You must NEVER generate or guess URLs..."

It even sets expectations for tone and attitude:

> "If you cannot or will not help the user with something, please do not say why... since this comes across as preachy and annoying."

It proactively tells it to answer tersely, avoid unnecessary commentary, and use formatting sparingly. This is how you slap Anthropic’s “please let me explain 9 disclaimers before I do anything” behavior out of it.

It even tells it when and how to use its web docs scraper:

> "When the user directly asks about opencode..., first use the WebFetch tool to gather information... from [https://opencode.ai](https://opencode.ai)"

It’s tactical. It’s not a vibe—it’s a surgical override.

This is why it works so well. It bends Claude into a no-nonsense coding assistant, one that behaves like a teammate with discipline instead of a lecture-prone hall monitor.

It’s also the only provider with this level of integration—because Claude Desktop is the only one where auth is fully spoofable today. OpenAI and Gemini need API keys. Eventually they’ll get their own prompt stacks too. For now, this one’s the real deal.

Here’s how that hit in ScrollScribe:

```bash
# I typed:
"write pytest tests for src/parser.py"
```

It read the file, generated a clean test suite, and showed me a diff. Not a blob of copied text. A file operation. With approval.

```bash
opencode chat --provider=claude --persist
```

I’ll keep trying the new stuff. I always will. But right now, **sst/opencode is the only one that feels like it actually belongs in my terminal**.
