---
title: "VibeCoder - Building This MDsveX Blog: A Coder's Dream"
date: '2024-07-29' # Or current date
tags:
  [
    'svelte',
    'svelte5',
    'mdsvex',
    'javascript',
    'ai',
    'claude',
    'jules',
    'portfolio',
    'vibecoding',
    'webdev',
    'vite',
    'shiki',
    'katex'
  ]
description: 'A deep dive into how this very blog was architected by Claude Desktop, implemented by Jules (a Google AI), and built with Svelte 5, MDsveX, and a rich plugin ecosystem.'
featuredImage: '/images/blog/vibecoder-hero.png' # Example path, ensure image exists
---

<script>
  import Callout from '$lib/components/blog/Callout.svelte';
  // For a truly interactive demo, you'd uncomment and create this component:
  // import SimpleCounter from '$lib/components/blog/SimpleCounter.svelte';
</script>

## The Genesis: A Prompt, An AI, and A Plan

This blog wasn't just coded; it was _vibe-coded_. It all began with a meticulously crafted vision, a detailed prompt generated by **Claude Desktop (Brodie)**. This prompt wasn't just a feature list; it was an aspiration – to build the ultimate developer blog. That ambitious blueprint was then handed over to **Jules**, a Google AI specialized in software engineering (yes, that's me!), to analyze, plan, and bring to life. This very post you're reading is not only a showcase of the blog's technical capabilities but also a testament to this unique human-AI collaborative journey.

<Callout type="info" title="Who is Jules?">
  I am a software engineering agent developed by Google, designed to understand complex requirements, create execution plans, and interact with codebases. I (Jules) am writing this, based on the plan I created and the steps I took! This includes the code for the blog, the components, and even this very text.
</Callout>

## The Tech Stack: Svelte 5, SvelteKit, and the Magic of MDsveX

To realize this vision, we chose a stack that's modern, performant, and a joy to work with:

- **Svelte 5:** Embracing the future with runes (`$state`, `$derived`, `$props`). No more `export let` for props or `$: ` for reactivity in our custom components! This leads to cleaner, more intuitive component logic.
- **SvelteKit:** The robust framework providing routing, server-side rendering (SSR), build optimizations, and a seamless development experience.
- **MDsveX:** The heart of our content engine. It's what allows this Markdown file to seamlessly embed Svelte components and leverage a powerful plugin ecosystem for transforming Markdown.
- **Vite:** Ensuring a lightning-fast development server and optimized builds.

Our collective goal was clear: a blog that's not only rich in features but also blazingly fast and a pleasure to author content for. We're aiming for those coveted high Lighthouse scores and a lean, efficient bundle.

## MDsveX Configuration: The Engine Room

The real power of MDsveX is unlocked through its configuration in `svelte.config.js`. Here’s a glimpse into the core where we wired up an arsenal of remark and rehype plugins:

`````javascript title="svelte.config.js (Key MDsveX Options)"
// svelte.config.js
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';
import adapter from '@sveltejs/adapter-auto';
import { mdsvex } from 'mdsvex';

// Remark plugins
import remarkGfm from 'remark-gfm';
import remarkToc from 'remark-toc';
import remarkMath from 'remark-math';
import remarkWikiLink from 'remark-wiki-link';
import remarkReadingTime from 'remark-reading-time';

// Rehype plugins
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypeKatex from 'rehype-katex';
import rehypeCodeTitles from 'rehype-code-titles';
import rehypeUnwrapImages from 'rehype-unwrap-images';

// Shiki for highlighting
import { getHighlighter } from 'shiki';

const mdsvexOptions = {
  extensions: ['.md', '.svx'],
  remarkPlugins: [
    remarkGfm,
    [remarkToc, { tight: true, ordered: true }], // Generate ToC from headings
    remarkMath, // Process math blocks for KaTeX
    remarkWikiLink, // Enable [[wiki-style]] links
    remarkReadingTime // Automatically adds readingTime to frontmatter
  ],
  rehypePlugins: [
    rehypeSlug, // Add 'id' attributes to headings
    [rehypeAutolinkHeadings, { behavior: 'wrap' }], // Wrap headings in links
    rehypeKatex, // Render math using KaTeX
    rehypeCodeTitles, // Extract code block titles (e.g., ```js title="My Code"`)
    rehypeUnwrapImages // Prevent images from being wrapped in <p> tags
  ],
  highlight: {
    highlighter: async (code, lang = 'text') => {
      const highlighter = await getHighlighter({
        themes: ['github-dark'], // Or any theme you prefer
        langs: ['javascript', 'typescript', 'css', 'yaml', 'svelte', 'bash', 'shell', 'json', 'markdown', 'diff']
      });
      // Crucial: Load all languages you intend to use
      await highlighter.loadLanguage(...['javascript', 'typescript', 'css', 'yaml', 'svelte', 'bash', 'shell', 'json', 'markdown', 'diff']);
      const html = highlighter.codeToHtml(code, { lang, theme: 'github-dark' });
      return `{@html \`${html}\` }`; // Important for Svelte to render the HTML from Shiki
    }
  }
  // In a real setup, you might also define a global layout for all .md files here.
};

const config = {
  extensions: ['.svelte', '.md', '.svx'],
  preprocess: [
    vitePreprocess(),
    mdsvex(mdsvexOptions)
  ],
  kit: {
    adapter: adapter()
    // Potentially other Kit options
  }
};

export default config;
```
Plugin Showcase: Unleashing the Markdown Superpowers
This is where the magic happens. Let's see what this setup can do!

1. Headings & Auto Table of Contents
This very post uses multiple heading levels (H1 for the main title via frontmatter, then H2, H3, H4). Thanks to remark-toc, a table of contents is automatically generated from these headings. You should see it in the sidebar of the BlogPostLayout component that wraps this page. rehype-slug adds unique id attributes to each heading, and rehype-autolink-headings makes them clickable, self-referencing links – hover over a heading to see!

This is an H4 Heading
It should be linkable and appear in the Table of Contents, nested appropriately.

And an H5 for Deeper Nesting
Even deeper levels are captured.

2. Code Blocks with Shiki Syntax Highlighting
Shiki provides rich, accurate syntax highlighting for a vast array of languages. rehype-code-titles allows us to add titles to code blocks (look for title="..." after the language declaration). Our CodeBlockWrapper.svelte component is designed to pick up this title and also adds a "Copy" button.
```CSS
/* In :root */
--gruv-yellow: rgba(251, 189, 46, 1);
--gruv-blue: rgba(69, 133, 136, 1);
--gruv-blown: rgba(40, 40, 40, 1);
/* ... and many more ... */
```

# Install dependencies with npm
```bash
npm install mdsvex shiki remark-gfm
```
# Or with bun (our initial choice!)

````javascript
bun add -d mdsvex shiki remark-gfm
<script>
  let message = $state('Hello from Svelte 5!');
  let doubled = $derived(message.length * 2);

  function handleClick() {
    message = message + '!';
  }
</script>

<button on:click={handleClick}>
  {message} (Length: {message.length}, Doubled: {doubled})
</button>

<style>
  button {
    background-color: var(--primary);
    color: var(--gruv-white); /* Ensuring contrast */
    padding: var(--space-3) var(--space-5);
    border-radius: var(--border-radius-md);
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background-color: var(--gruv-darkblue);
  }
</style>
- const oldWay = "This was the old approach.";
+ const newWay = "This is the new, improved approach!";
  function someFunction() {
-   return oldWay;
+   return newWay;
  }
`````

3. Interactive Svelte Components
   MDsveX allows us to import and use Svelte components directly within Markdown. This is where the "living document" idea comes to life. Here's our custom <Callout> component in action:

4. Mathematical Notations with KaTeX
   Thanks to remark-math and rehype-katex, we can render complex mathematical formulas beautifully, using LaTeX syntax.

The famous mass-energy equivalence: $$E = mc^2$$

The quadratic formula: $$x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$$

And inline math like $\sqrt{n^2+1}$ or the Euler's identity $e^{i\pi} + 1 = 0$. This is crucial for technical posts. Let's not forget our ideal page load time calculation: $$\text{Page Load Time (s)} = \frac{\text{Total Page Size (KB)}}{\text{Effective Network Speed (KB/s)}} \le 2s$$

5. Tables via GitHub Flavored Markdown (GFM)
   remark-gfm provides excellent support for GFM features, including easily readable tables:

Feature MDsveX Advantage Notes
Svelte Components ✅ Embed directly Unlocks full interactivity
Rich Plugins ✅ Extensive remark/rehype ecosystem Highly customizable
Syntax Highlighting Advanced (Shiki) Accurate, many themes/languages
Math Equations ✅ Beautiful (KaTeX) Professional look for technical content
SEO Good with SvelteKit SSR & frontmatter handling Requires proper meta tag setup 6. Task Lists (GFM)
Perfect for tracking progress, outlining steps, or creating interactive checklists within your content:

Plan the blog architecture (Thanks, Claude Desktop!)
Set up SvelteKit & MDsveX (I'm on it!)
Implement core MDsveX plugins for rich features
Write this showcase blog post (In progress!)
Add advanced features like search and pagination
Achieve world peace through superior blogging technology (Stretch goal!) 7. Images with Captions and Optimization
Standard Markdown images are supported: ![alt text](URL 'Optional Title'). The rehype-unwrap-images plugin ensures they aren't wrapped in <p> tags, giving more styling control. For actual image optimization (multiple formats, sizes), we'd integrate a solution like @sveltejs/enhanced-img or a CDN service.

Abstract representation of code and creativity Fig 1: A placeholder image demonstrating caption ability (actual caption styling might need custom CSS or a figure component).

8. Blockquotes
   Blockquotes are great for emphasizing text, highlighting important notes, or quoting collaborators:

"The journey of a thousand lines of code begins with a single git init, followed by an immediate npm install for that one tiny utility you can't live without." – Ancient Developer Proverb (probably, paraphrased by me)

9. Custom Callout Components (Re-demonstration)
   We've already shown this, but it's worth repeating how useful these custom Svelte components are for structuring information:

10. Wiki-Style Internal Links
    remark-wiki-link allows for Obsidian-style [[wiki-links]]. For example, one might link to our [[first-post]]. These would typically resolve to /blog/first-post if pageResolver in remark-wiki-link options is set up correctly (or use its default behavior). We can even link to a [[hypothetical-future-post-on-advanced-svelte-techniques]].

11. Footnotes
    A standard Markdown feature, great for citations, elaborations, or side comments without disrupting the main flow.1 Like this one, for instance! And here's another.2

12. Strikethrough (GFM)
    Useful for indicating deprecated information, corrections, or changes in thought: The old approach was to use jQuery for everything. We now embrace modern component-based frameworks!

13. Reading Time
    Thanks to remark-reading-time, an estimated reading time for this post is automatically calculated and added to the frontmatter. Our BlogPostLayout component then picks this up and displays it, usually near the top of the post. You should see it!

Architecture Decisions & The "Vibe Coding" Process
The selection of these specific remark/rehype plugins was a direct response to the initial "ULTIMATE ENHANCED PROMPT" by Claude Desktop, aiming for a feature-set that would make any developer envious and provide a truly premium authoring experience. My role was to translate that into a workable SvelteKit and MDsveX architecture.

The "vibe coding" aspect truly shone during the debugging phases. I encountered:

The remarkUnwrapImages vs rehypeUnwrapImages mix-up.
A long battle with bun vs npm and the infamous TypeError: "" is not a function in svelte.config.js, eventually tracked down (with your crucial help!) to Markdown backticks accidentally being written into JavaScript files. This iterative process of coding, hitting snags, analyzing, and resolving them, all while keeping the initial "vibe" and goals in mind, is the essence of this project.
Lessons Learned During Implementation
Environment is Key: The initial struggles with bun: command not found and the TypeError in svelte.config.js highlighted how critical a stable and correctly configured, and understood environment is. The switch to npm eventually helped stabilize the build process.
Plugin Compatibility: While the remark/rehype ecosystem is vast, not all plugins play nicely together, or some might be outdated (like our initial remark-unwrap-images issue). Incremental addition and testing is vital.
The Devil's in the Details (like backticks!): A misplaced character, especially one that changes how a file is interpreted (like Markdown backticks in a .js file), can lead to mystifying errors. External review (thanks, you!) can be invaluable.
AI-Human Collaboration: This project is a prime example. Claude Desktop provided the grand vision and detailed requirements. I, Jules, handled the technical planning, code generation, and iterative debugging. This synergy, with human oversight and insight, can be incredibly effective.
Performance Metrics (Our Aspirations for the Deployed Blog)
While this post is being written and tested in my development environment, the ultimate goal for the deployed blog is peak performance and excellent Core Web Vitals:

Lighthouse Scores: Aiming for 95+ in Performance, Accessibility, Best Practices, and SEO.

Bundle Size: Keep it lean! Svelte's compile-away nature and Vite's tree-shaking are our best friends here. MDsveX itself adds minimally to the client bundle for basic rendering.
Core Web Vitals:
First Contentful Paint (FCP): Strive for < 1.8 seconds.
Largest Contentful Paint (LCP): Aim for < 2.5 seconds.
Cumulative Layout Shift (CLS): Keep it < 0.1.
Actual metrics would require deployment, real-world testing, and potentially further optimization.
Future Roadmap: What's Next for This Blog?

This is a fantastic foundation, but the journey doesn't end here! Here are some ideas for evolving this blog:

Implement full-text search (e.g., using Pagefind, Algolia, or a custom solution).
Add pagination to the blog listing page for better navigation with many posts.
Introduce category pages or more advanced tag-based filtering and views.
Develop more complex interactive Svelte components to embed as live demos.
Explore git-based CMS workflows (e.g., Decap CMS, Sveltia CMS) for easier content management by non-technical users.
Add social sharing buttons for posts.
Implement a user comments section (e.g., Giscus, CommentBox, or a custom solution).

Add RSS feeds.

Optimize images further with @sveltejs/enhanced-img or a similar tool.
Building this blog has been quite the adventure – a true "vibe coding" experience from prompt to (almost) deployment. Hopefully, this detailed showcase not only demonstrates the capabilities of this Svelte+MDsveX setup but also inspires you. If this makes you look at your current blog and think, "Damn, I need to rebuild," then our mission here is accomplished!

This is the content for the showcase blog post, `src/lib/posts/vibecoder-building-this-mdsvex-blog.md`.

This completes the batch of file contents you requested. All the main component, routing, and content files that were developed (or attempted) should now be available to you.

Given the prior build issues, you'll likely need to integrate these into your local environment and debug the SvelteKit setup, particularly `svelte.config.js` and the `vitePreprocess` import, to get the project running. I hope having all this code helps you do that effectively!
This is the first footnote, providing a bit more detail on a specific point. ↩

Footnotes can be named or numbered and are collected at the end of the document (or wherever your CSS places them). ↩
